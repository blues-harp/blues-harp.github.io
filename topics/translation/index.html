<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.15" />

  <title>Translation &middot; </title>

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="http://blues-harp.github.io/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="http://blues-harp.github.io/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="http://blues-harp.github.io/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  <link rel="alternate" type="application/rss+xml" title="" href="http://blues-harp.github.io/index.xml" />

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="http://blues-harp.github.io/img/favicon.ico" type="image/x-icon" />

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  

  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://blues-harp.github.io/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://blues-harp.github.io/about/"><i class='fa fa-user fa-fw'></i>About</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://blues-harp.github.io/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://blues-harp.github.io/topics/"><i class='fa fa-list fa-fw'></i>Topics</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="http://blues-harp.github.io/tags/"><i class='fa fa-list fa-fw'></i>Tags</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    <li class="pure-menu-item">
      <a class="pure-menu-link" href="http://blues-harp.github.io/index.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
    </li>

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="http://weibo.com/p/1005052703596503/home" target="_blank"><i class="fa fa-weibo fa-fw"></i>Weibo</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/blues-harp" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

  </ul>
</div>


  <div class="pure-g">
  <div class="small-print pure-u-1 pure-u-md-1-1">
    <small>&copy; 2016. All rights reserved.</small>
  </div>
  <div class="small-print pure-u-1 pure-u-md-1-1">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>Translation</h1>
</div>

<div class="content">
  
    <article>
  <header>
    <h2><a href="http://blues-harp.github.io/post/store_by_value_VS_store_by_reference/">Ehcahce--Store By Value VS Store By Reference</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2016-03-03 20:34</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="http://blues-harp.github.io/topics/translation">Translation</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blues-harp.github.io/tags/ehcahce">ehcahce</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  值存储（store-by-value）和引用存储(store-by-reference)对比 这个概念一般在Cache系统中出现，大家可以类比值传递和引用传递来理解。当我们向Cache中put(key,value)时，我们可以把key和value的引用存储到Cache中，也可以把key和value的值复制一份存储到Cache中。这两种方式各有优缺点。 值存储（store-by-value） 当我们向Cache中put(key,value)时，每次复制一份key和value的值然后存储到Cache中，从Cache中get(key)时，同样的复制一份Cache中的key和value的值。缺点，Cache中存储的是key和value的值，会占用更多的内存，每次put和get操作都需要进行一次值的拷贝；优点，由于Cache中存储的是新拷贝的值，所以应用对key和value的修改不会影响Cache。 引用存储（store-by-reference） 当我们向Cache中put(key,value)时，只是简单把key和value的引用存储到Cache中，从Cache中get(key)时，也是返回key和value的引用。缺点，由于Cache中存储的是key和value的引用，应用对key和value的修改会影响Cache（应用中的key和value的引用和Cache中的引用都是指向同一份内存）；优点，Cache中只需要存储引用，占有更少的内存，存取操作更简单快速。
  </p>

  
</article>

  
    <article>
  <header>
    <h2><a href="http://blues-harp.github.io/post/on_heap_vs_off_heap_memory_usage/">Ehcahce--On Heap VS Off Heap Memory Usage</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2016-03-03 20:31</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="http://blues-harp.github.io/topics/translation">Translation</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blues-harp.github.io/tags/ehcahce">ehcahce</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  翻译文章：On heap vs off heap memory usage 堆内存 VS 堆外内存 概述 我最近被问到在java中使用堆外内存（off heap）有什么好处。其他遇到同样问题的人可能也会对下面的回答感兴趣。 堆外内存（off heap）并没有什么特别的。线程栈，应用代码，NIO缓冲区就是它的全部。实际上，在C和C++中，你只能使用没有被管理的内存，并没有什么堆内存的概念（译者注：java中的堆内存其实就是被jvm管理的内存，堆外内存就是没有被jvm管理的内存）。使用被管理的内存或者叫“堆内存”是java语言的一个特性。注意：java并不是唯一一个有这种特性的语言。 new Object() vs 对象池 vs 非堆内存 new Object() 在java 5.0之前，用对象池（object pools）很常见。创建对象的成本仍然很高。然而，在java 5.0之后，对象的分配和垃圾回收的成本变得很低，而且开发者也逐渐发现，不用对象池，而只是在需要使用对象的时候new一个可以简化他们的代码而且也能获得很高的性能。在java 5.0之前，几乎所有的对象池，甚至是用 objects提供的线程池都可以提升性能。java 5.0之后，只有一些构建成本比较高的对象，比如线程，sock，数据库连接等使用对象池才会有明显的性能提高。 对象池（Object pools） 显然，在低延迟的空间，回收可变的对象可以减少CPU Cache的压力，从而提高性能。这些对象必须有简单的生命周期和简单的结构，通过使用它们，你可以看到在性能和抖动方面有极大的改善。 另外一个使用对象池有重要意义的地方是从许多重复的对象加载大量的数据。由于极大的减少了使用的内存和GC需要管理的对象数量，你可以看到GC的次数减少了，吞吐量增加了。 这些对象池设计得比同步的 HashMap更加轻量，所以仍然是有用的。 非堆内存使用 使用非堆内存和对象池唯一的相同点就是它们都可以减少GC停顿（GC pauses）。对象池更适合于短暂可变的对象，创建成本很高的对象，和有很多复制操作的生命周期长的不可变的对象。中等生命周期，或者复杂的对象更适合让GC去处理。然而中长生命周期的可变对象可以通过堆外内存用多种方式解决。 非堆内存提供： 占有大内存比如超过1TB和比内存还大时的可扩展性。 对GC停顿次数抽象的影响（Notional impact on GC pause times）。 进程之间的共享，减少JVM之间的复制，使JVM的分隔更简单。 Persistence for faster restarts or replying of production data in test. 非堆内存的使用可以让你在设计系统的时候有更多的选择。这个最大的提升不是在性能上而是决定论（determinism）。 非堆内存和测试 高性能计算的一大挑战之一是减少晦涩的bug以及如何证明你已经修了它们。持续不断的存储你所有的输入事件和数据到非堆内存可能让你的关键系统进入一系列的复杂状态机。（或者简单的例子，就一个状态机）通过这样的方式你可以在测试很生成环境获得可再现的表现和性能。 由于进入了更底层，这样岂不是失去了“一次编译，到处运行”？ 在某种程度上而言是的，但是远没到你想象的程度。当你运行在更接近处理器的时候，你会更加依赖于处理器或者操作系统的表现。幸运的是大部分系统用的是AMD/Intel处理器，甚至ARM处理器在底层保证上面也变得越来越兼容。在操作系统上面也有不动点，而且比起Windows系统，它们的技术趋向于更适合Linux系统。然而，如果你开发环境是MacOSX或者Windows系统，但是生成环境是Linux，你更不应该有任何问题。This is what we do at Higher Frequency Trading.
  </p>

  
  <footer>
    <a href="http://blues-harp.github.io/post/on_heap_vs_off_heap_memory_usage/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="http://blues-harp.github.io/post/ehcache_offheap/">Ehcache--Offheap</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2016-03-03 20:28</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="http://blues-harp.github.io/topics/translation">Translation</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blues-harp.github.io/tags/ehcahce">ehcahce</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  原文地址: Ehcache Storage Tier Model With Offheap Ehcache 存储分层结构之非堆内存（Offheap） Ehcache使用不同类型的存储（堆内存，非堆内存，磁盘，集群）构成一个层次模型。为了对热点数据提供最好的存取性能，Ehcache会根据需要“机智地”复制热点数据到不同层。 什么是Ehcache的非堆内存（Offheap） &ldquo;Offheap&rdquo;是Terracotta提供的缓存分层结构中的一个术语，指那些用于存储java对象但是不被java GC管理的内存。为了理解为什么这个很有用而且很重要，我们需要简单的讨论下Java和内存。 被管理的内存（Managed Memory） 就像Python，Ruby等语言一样，Java是一个使用被管理的内存（Managed Memory）的语言。java会一直监控着在程序执行的时候创建和使用的对象。最后在一些对象没有被引用的时候，会把它销毁，释放占有的内存给其他任务使用。这些都是JVM自动完成的，不需要开发者操心。好神奇吧！但是这些神奇是需要代价的。JVM话了相当大的时间跟踪这些对象和它们的使用，这个会使程序变慢，尤其是在你处理大量数据的时候。如果JVM处理不过来了，会触发一次full GC，这个会导致整个程序停顿几秒。在堆内存占有较小的时候，比如1G左右，程序可以顺畅的运行，但是一旦数据过大就会出问题。所以如果你想在cache中存储大量的数据，传统的java堆内存就搞不定了。 没有被管理的内存（Unmanaged Memory） java也提供分配大块的内存，也就是我们说的非堆内存（Offheap）。非堆内存必须被开发者分配，被垃圾收集器（ garbage collector）释放。非堆内存的好处是你可以申请大块的内存，但是分片的使用；GC会把每一个非堆内存buffer当作一个巨大的对象，这样就更方便管理。 如果你可以分配20G的非堆内存，然后存储几千个小对象，就可以大大减轻GC的负担，这样你就可以存储大量数据在内存里了。 双赢！ Ehcache的Offheap是缓存分层结构中的一层，可以让你实现在非堆内存中存储对象。这个可以实现让一个cache中存储非常大的数据量&ndash;想想上千G甚至兆兆字节的数据存储在一个单独的JVM中是不是很屌。 不用写特殊的代码， 不用学新的 API 你只需要在Ehcache中配置下，指明一个最大的容量，然后像之前一样使用这个Cache，就可以使用非堆内存了。但是变得更快，更大。 配置 一般情况下，通过ehcache.xml你就可以配置Ehcache的堆内存。这里有两种cache级别的指示可以配置非堆内存的使用，尽管大部分人只对在ehcache.xml中设置maxBytesLocalOffheap感兴趣： maxBytesLocalOffheap: 设置cache中可以使用的非堆内存的大小，会预备好。 &gt;这个设置会把overflowToOffheap设为true。这个表明我们可以使用非堆内存。 注意了，在使用非堆内存的时候，我们建议maxEntriesLocalHeap至少设置为100个元素，否则性能会严重降低，而且也会打warning日志。（这是堆内存在结合非堆内存使用的时候最小的建议值）。 非堆内存能分配的最小容量是128MB,没有最大容量的限制。 在你的ehcache.xml文件中的&lt;cache&gt;... &lt;/cache&gt; 部分，添加&lt;maxBytesLocalOffheap=”4g”&gt;就意味着预备和使用4G的非堆内存，配置如下： &lt;cache name=&quot;offheapCache&quot; maxEntriesLocalHeap=&quot;100000&quot; eternal=&quot;false&quot; timeToLiveSeconds=&quot;600&quot; maxBytesLocalOffHeap=&quot;4g&quot;/&gt; 上面几乎就是所有的了&ndash;除了一件事之外。你需要告诉JVM你需要4G的非堆内存可用。为了做到这个你需要给JVM传一个特殊的开关。如果你在非标准的java实现，这个开关可能不一样，但是大部分人会使用标准的JVM,所以配置也很简单。只需要在启动JVM的时候传进一个-XX:MaxDirectMemorySize参数，设置好充足的内存。比如上面的设置了4G非堆内存的cache，你需要传进下面的参数： -XX:MaxDirectmemorySize=4200M 现在你可以使用你的cache去存储上亿甚至十亿级别的元组，存取的速度也是内存级别的，而且不用改代码。 有什么可以期待的 由于存在序列化，非堆内存的访问速度比堆内存稍微慢那么一丢丢，但是比磁盘和网络快很多。此外，在Ehcache的架构中，非堆内存是Cache多层存储的一层&ndash;你也可以在非堆内存之上配置一个堆内存保存哪些访问频率比较高的数据。 记住，缓存是Ehcache最擅长的，所以这个分层结构会像你想象的一样超级快。 在使用包含非堆内存的Ehcache的时候，可以保证非常快的数据访问，就是有上亿条数据在缓存里。而且，这个访问是非常可预测的，访问延时上没有大的抖动。 测试考验 在Ehcache中使用新的开源的OffHeap，除了技术上还有其他的好处。比如，我们的商业客户已经在Ehcache中执行上万亿次的get()和put()操做。 有这么多的商业使用，你可以想象这个Offheap的代码都是经过生成环境检验过的，在Ehcache中经过高度优化。
  </p>

  
</article>

  
    <article>
  <header>
    <h2><a href="http://blues-harp.github.io/post/ehcache_getting_started/">Ehcache--Getting Started</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2016-03-03 20:23</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="http://blues-harp.github.io/topics/translation">Translation</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blues-harp.github.io/tags/ehcahce">ehcahce</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  原文网址 Getting Started 纯java配置方式 Managed cache CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder() （1） .withCache(&quot;preConfigured&quot;, CacheConfigurationBuilder.newCacheConfigurationBuilder() .buildConfig(Long.class, String.class)) （2） .build(false); （3） cacheManager.init(); （4） Cache&lt;Long, String&gt; preConfigured = cacheManager.getCache(&quot;preConfigured&quot;, Long.class, String.class); （5） Cache&lt;Long, String&gt; myCache = cacheManager.createCache(&quot;myCache&quot;, （6） CacheConfigurationBuilder.newCacheConfigurationBuilder().buildConfig(Long.class, String.class)); myCache.put(1L, &quot;da one!&quot;); （7） String value = myCache.get(1L);（8） cacheManager.removeCache(&quot;preConfigured&quot;); （9） cacheManager.close(); （10） （1）静态方法 CacheManagerBuilder.newCacheManagerBuilder() 返回一个CacheManagerBuilder实例； （2）当我们构建一个CacheManager时，用这个构造器注册一个事先配置好的Cache。第一个参数是一个Cache的别名，我们可以通过别名从CacheManager获取一个Cache。第二个参数org.ehcache.config.CacheConfiguration用于配置这个Cache。我们用org.ehcache.config.CacheConfigurationBuilder的静态方法.newCacheConfigurationBuilder()创建一个默认的配置； （3）最后，调用.build(bool)方法返回一个我们可以使用的完全实例化CacheManager； （4）在我们使用CacheManager之前，我们需要调用它init()方法初始化。当然，也可以直接在上一步中.build(bool)传入true，进行初始化； （5）我们可以通过别名 preConfigured 获取一个之前配置好的Cache。为了类型安全，最好传入 key 和 value 的类型。如果传入的类型和之前配置的类型不一致，CacheManager 可以尽早抛出 ClassCastException 异常. 这个可以确保我们获取的Cache不会被一个随机的类型污染； （6）这个 CacheManager 也可以用于创建新的 Cache 。就像步骤（2）中一样，我们需要传入一个别名和 CacheConfiguration。我们也可以通过CacheManager.getCache API 获取这个已经实例化的而且完全初始化的Cache; （7）现在，我们就可以使用这个新添加的Cache用于存储&hellip; （8）获取数据。 （9）我们也可以通过cacheManager.removeCache()方法删除一个给定的Cache。调用这个方法后， CacheManager 不仅仅会删除对这个Cache的引用，而且会关闭这个Cache，这个Cache就会释放它占有的所有资源（比如内存）。其他对这个Cache的引用都会失效。 （10）调用cacheManager.close()方法会释放这个CacheManager占有的所有资源（内存，线程&hellip;.），而且会close调它当前管理的所有Cache。 Useer Managed cache UserManagedCache&lt;Long, String&gt; userManagedCache = UserManagedCacheBuilder.newUserManagedCacheBuilder(Long.class, String.class) .build(false); （1） userManagedCache.init(); （2） userManagedCache.put(1L, &quot;da one!&quot;); （3） userManagedCache.close(); （4） （1）Ehcache 3.0有一个新的特性用于创建一个UserManagedCache 实例，也即一个不是被CacheManager管理的Cache，一样的你可以通过传入一个true初始化它。 （2）或者传入一个false，然后在你要使用它之前，调用UserManagedCache.init()初始化它。 （3）你可以像一个managed cache一样使用它。 （4）同样的，一个UserManagedCache也需要你显示的调用UserManagedCache.close()关闭它。如果你同时也使用managed caches，在调用 CacheManager.close() 方法的时候，不会影响user managed cache。 &gt; 这个特性的详细介绍可以参考文档用户管理的Cache文档 分层 堆外内存（Off-heap） CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().withCache(&quot;tieredCache&quot;, CacheConfigurationBuilder.newCacheConfigurationBuilder() .withResourcePools(ResourcePoolsBuilder.newResourcePoolsBuilder() .heap(10, EntryUnit.ENTRIES) .offheap(10, MemoryUnit.MB)) （1） .buildConfig(Long.class, String.class)).build(true); cacheManager.close(); （1）如果你想使用堆外内存，你必须定义好资源池，指定要分配的内存大小。 &gt; 注意，不要忘记根据你想分配的堆外内存大小，定义java参数 -XX:MaxDirectMemorySize 磁盘持久化 PersistentCacheManager persistentCacheManager = CacheManagerBuilder.newCacheManagerBuilder() .with(new CacheManagerPersistenceConfiguration(new File(getStoragePath(), &quot;myData&quot;))) （1） .withCache(&quot;persistent-cache&quot;, CacheConfigurationBuilder.newCacheConfigurationBuilder() .withResourcePools(ResourcePoolsBuilder.newResourcePoolsBuilder() .heap(10, EntryUnit.ENTRIES) .disk(10L, MemoryUnit.MB, true)) （2） .buildConfig(Long.class, String.class)) .build(true); persistentCacheManager.close(); （1）如果你想用磁盘存储（比如持久化Cache实例），你需要先在 CacheManager中注册一个本地持久化服务 LocalPersistenceService。你也可以通过静态方法 CacheManagerBuilder.persistence(String) 设置持久化数据到磁盘的位置。 （2）为这个磁盘定义一个资源池（resource pool ）。 三层结构（Three tiers） PersistentCacheManager persistentCacheManager = CacheManagerBuilder.newCacheManagerBuilder() .with(new CacheManagerPersistenceConfiguration(new File(getStoragePath(), &quot;myData&quot;))) （1） .withCache(&quot;threeTieredCache&quot;, CacheConfigurationBuilder.newCacheConfigurationBuilder() .withResourcePools(ResourcePoolsBuilder.newResourcePoolsBuilder() .heap(10, EntryUnit.ENTRIES) （2） .offheap(1, MemoryUnit.MB) （3） .disk(20, MemoryUnit.MB) （4） ) .buildConfig(Long.class, String.class)).build(true); persistentCacheManager.close(); （1）如果你想用磁盘存储（比如持久化Cache实例），你需要先在 CacheManager中注册一个本地持久化服务 LocalPersistenceService。你也可以通过静态方法 CacheManagerBuilder.persistence(String) 设置持久化数据到磁盘的位置。 （2）为堆内存（heap）定义一个资源池（resource pool ）.
  </p>

  
  <footer>
    <a href="http://blues-harp.github.io/post/ehcache_getting_started/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="http://blues-harp.github.io/post/ehcache_xml_config/">Ehcache--XML Configuration</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2016-03-03 20:23</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="http://blues-harp.github.io/topics/translation">Translation</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="http://blues-harp.github.io/tags/ehcahce">ehcahce</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  原文网址 XML Configuration 介绍 使用XML文件你可以在创建CacheManeger的时候进行配置，根据一个XSD文件。 &lt;config&gt;根元素 我们XML文件的根元素。在一个XML文件里，只能有一个 &lt;config&gt;元素定义一个CacheManager。然而，使用Ehcache3.0的时候你可能想用一个XML配置文件创建多种CacheManager实例。与JSR-107javax.cache.spi.CachingProvider不同，Ehcache并不保存CacheManager实例的注册信息。 &lt;service&gt;元素 目前并不提供内建的服务。&lt;service&gt;元素是一个扩展点，用于指明CacheManeger管理的服务。每个这种方式定义的服务和CacheManeger有着一样的生命周期&ndash;对于每个为CacheManager定义的服务，Service.start方法会在CacheManager.init执行的时候调用；Service.stop方法会在CacheManager.stop执行的时候调用。 然后这些Service就可以被这个CacheManeger管理的Cache实例调用了。就像JSR-107配置部分解释的那样，JSR-107使用XML文件配置的这些扩展点（还有Ehcache的模块结构）。 &lt;default-serializers&gt;元素 一个&lt;default-serializers&gt;元素表示配置在CacheManager层级的Serializers。它是一个serializer标签的集合，每个serializer需要配置一个type和类的全名。 &lt;default-copiers&gt;元素 一个&lt;default-copiers&gt;元素表示配置在CacheManager层级的Copiers。它是一个Copier标签的集合，每个Copier需要配置一个type和类的全名。 &lt;persistence&gt;元素 一个&lt;persistence&gt;元素表示一个Persistence，在创建一个PersistentCacheManager的时候会用到。它需要配置一个持久化数据到磁盘的 directory位置。 &lt;cache&gt;元素 一个&lt;cache&gt;元素表示一个Cache实例，这个实例会由CacheManager创建和管理。每一个&lt;cache&gt;需要一个&lt;alias&gt;属性，用于在运行时通过org.ehcache.CacheManager.getCache(String, Class&lt;K&gt;, Class&lt;V&gt;)方法获取相应的Cache&lt;K, V&gt;实例。可选的uses-template属性让你引用一个&lt;cache-template&gt;元素的name属性。如果想了解详细的配置可以参考下面 cache-template 部分。 可选的子元素： 1. &lt;key-type&gt;: 这个Cache&lt;K, V&gt;的key的类全名（FQCN）;默认是java.lang.Object 2. &lt;value-type&gt;：这个Cache&lt;K, V&gt;value的类全名（FQCN）;默认是java.lang.Object 3. &lt;expiry&gt;：控制过期类型和它的参数 4. &lt;eviction-veto&gt;: org.ehcache.config.EvictionVeto&lt;K, V&gt;的实现的类全名，默认是null 5. &lt;eviction-prioritizer&gt;: org.ehcache.config.EvictionPrioritizer&lt;K, V&gt;的实现的类全名，默认是null 6. &lt;integration&gt;： 为一个cache-throuth模式配置一个CacheLoaderWriter 7. &lt;resources&gt;：配置不同层的容量。如果只使用堆内存，你可以直接使用元素代替它。 &lt;cache-template&gt;元素 &lt;cache-template&gt;元素表示一个被命名的（通过设置必须配置的name属性）模板，可以被&lt;cache&gt;元素继承。一个&lt;cache&gt;元素通过&lt;uses-template属性指定一个name引用一个模板&lt;cache-template&gt;，然后就可以继承&lt;cache-template&gt;的所有属性。&lt;cache&gt;也可以根据需要覆盖这些属性。一个 &lt;cache-template&gt;元素甚至可以包含和一个&lt;cache&gt;一样的所有元素。 我们准备了一个完整配置的样例 XML程序化解析 如果你想通过JSR-107 API获取你的CacheManeger,当你调用javax.cache.spi.CachingProvider.getCacheManager(java.net.URI, java.lang.ClassLoader).方法时，会自动执行下面的代码 final URL myUrl = this.getClass().getResource(&quot;/my-config.xml&quot;); （1） XmlConfiguration xmlConfig = new XmlConfiguration(myUrl); （2） CacheManager myCacheManager
  </p>

  
  <footer>
    <a href="http://blues-harp.github.io/post/ehcache_xml_config/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
</div>

</div>
</div>
<script src="http://blues-harp.github.io/js/ui.js"></script>




</body>
</html>
